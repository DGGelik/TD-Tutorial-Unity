### День 1 — Создание проекта

1. Запусти **Unity Hub**  
   (ищи значок U на рабочем столе или в поиске Windows)

2. Нажми большую синюю кнопку **New project** (справа сверху)

3. В разделе **Core** выбери шаблон **2D** или **Universal 2D**  
   → если написано Download — нажми и подожди

4. В поле **Project name** напиши: `TowerDefence2026`

5. Нажми **…** рядом с Location → создай папку `UnityProjects` на диске D: (или C:) → выбери её → OK

6. Нажми **Create project** (синяя кнопка внизу)

7. Подожди 1–3 минуты — откроется редактор Unity

Готово!  
В Hierarchy уже есть **Main Camera** и **Directional Light** — проект создан.
### После открытия проекта — подробная настройка первой сцены

**7. Открываем окно Project и находим папку Scenes**

- Внизу экрана (обычно самая нижняя панель) находится окно **Project**  
  Если его нет → внизу экрана кликни по вкладке **Project** (может быть свёрнута)

- Внутри окна Project слева видишь папку **Assets**  
  → кликни на стрелочку слева от слова **Assets**, чтобы раскрыть содержимое

- Внутри Assets ищи папку **Scenes** → раскрой её

**Зачем это делать?**  
Unity по умолчанию создаёт тестовую сцену SampleScene.unity.  
Она нам не нужна — мы будем делать свою игру с чистого листа.

**8. Удаляем ненужную сцену SampleScene.unity**

- В папке Scenes найди файл **SampleScene.unity**  
- Кликни по нему **правой кнопкой мыши**  
- Выбери **Delete**  
- В появившемся окошке подтверждения нажми **Delete** (или Yes)

**Почему обязательно удалить?**  
- Если оставить — при запуске проекта будет загружаться именно эта сцена (пустая с кубиком и камерой)  
- Позже при сборке билда эта сцена тоже попадёт в игру → лишний мусор  
- Удаление помогает сразу привыкнуть, что мы работаем только со своими сценами

**9. Создаём новую чистую сцену**

- В верхнем меню Unity нажми: **File** → **New Scene**  
- Появится маленькое окошко «Create New Scene»  
- Выбери шаблон **Basic (Built-in)** (самый простой и чистый вариант)  
- Нажми **Create**

**Почему именно Basic (Built-in)?**  
- Это самая простая сцена: только Main Camera + Directional Light  
- Нет лишних настроек освещения, пост-обработки, URP/HDRP — меньше шансов запутаться  
- Для классического 2D Tower Defense этого более чем достаточно

**10. Сразу сохраняем сцену под понятным именем**

- После создания новой сцены нажми: **File** → **Save Scene As…**  
  (или горячие клавиши Ctrl + Shift + S)

- В окне сохранения:  
  - слева выбери папку **Assets**  
  - если внутри Assets уже есть папка **Scenes** — открой её  
  - если нет → правой кнопкой в Assets → **Create** → **Folder** → назови **Scenes** → открой её

- В поле **File name** внизу напиши: **Main**  
- Нажми **Save**

**Почему важно сразу сохранить и назвать Main?**  
- Без сохранения сцена существует только в памяти → закроешь Unity — всё пропадёт  
- Название Main.unity сразу понятно: это главная игровая сцена  
- Позже, когда сцен станет много (меню, уровень 1, уровень 2), сразу будет ясно, какая главная

**11. Настраиваем камеру под 2D-игру**

- В левой панели **Hierarchy** найди объект **Main Camera** → кликни по нему один раз

- Справа откроется панель **Inspector** — там все настройки выбранного объекта

Изменяем три важных поля:

- **Projection**  
  → рядом с надписью Perspective кликни на стрелочку вниз  
  → выбери **Orthographic**  
  **Зачем?** В 2D-играх не нужна перспектива (удаление вдаль). Orthographic делает всё плоским и одинакового размера — как в старых платформерах и tower defense.

- **Size**  
  → сотри текущее число (обычно 5)  
  → напиши **5.5** → нажми Enter  
  **Зачем?** Это высота видимой области в игровых единицах.  
  При размере 5.5 видно примерно 11 единиц по вертикали — удобно для карты 10–12 клеток в высоту.

- **Background**  
  → кликни на цветной квадратик рядом с надписью Background  
  → внизу откроется цветовой круг + поле **Hex Color**  
  → в поле Hex напиши **1A3C1A** (без решётки) → нажми Enter  
  **Зачем?** Тёмно-зелёный фон хорошо сочетается с травой и дорогой, не раздражает глаза и сразу понятно, что это поле/карта.

**12. Финальное сохранение**

- Нажми **Ctrl + S** или **File → Save**

**Проверка результата дня:**

- Нажми кнопку **Play** (треугольник сверху посередине)  
- Экран должен стать тёмно-зелёным и пустым  
- Нажми Play ещё раз → остановка

Если всё так — день пройден идеально!
**Результат дня 1**  
Пустая сцена, камера настроена, фон тёмно-зелёный, сцена сохранена как Main.unity.

---
### День 2 — Tilemap + импорт спрайтшита + первая карта

**Цель дня:**  
Установить нужный пакет → найти/сгенерировать спрайтшит → нарезать его → настроить Tile Palette → нарисовать карту с травой и дорогой.

#### 1. Устанавливаем пакет 2D Tilemap Extras (если его нет)
1. В верхнем меню Unity: **Window** → **Package Manager**
2. В открывшемся окне слева вверху переключите выпадающий список на **Unity Registry**
3. В поле поиска (вверху) напишите: `2D Tilemap Extras`
4. Найдите пакет **2D Tilemap Extras** → если кнопка **Install** активна — нажмите её
   → подождите 10–60 секунд, пока установится

**Зачем?**  
Этот пакет добавляет полезные инструменты для Tilemap (Brush, правила соединения тайлов и т.д.).  
В Unity 2022.3+ и 6.x он часто уже предустановлен, но лучше проверить.

**Если пакета нет в списке** — ничего страшного, базовый Tilemap работает и без него.

#### 2. Где взять спрайтшит (подробно, 4 реальных варианта)

**Вариант 1 — Самый быстрый и надёжный (рекомендую новичкам)**  
Kenney.nl — бесплатные пиксель-арт ассеты (лицензия CC0)

1. Открой браузер → зайди на сайт: https://kenney.nl/assets
2. В поисковой строке напиши: **tower defense**
3. Выбери один из этих наборов (все подходят для 2D TD):
   - **Tower Defense (Top-Down)** — самый популярный, ~300 тайлов
   - **Tower Defense Kit**
   - **Platformer Art Deluxe** (есть тайлы травы и дорог)
4. Нажми **Download** → скачается ZIP-архив
5. Распакуй архив → найди файл **spritesheet.png** или **tilemap.png** (обычно один большой лист 4096×4096 или похожий)

**Вариант 2 — Сгенерировать свой уникальный спрайтшит в нейросети**
1. Зайди на один из бесплатных генераторов:
   - Leonardo.AI (бесплатно 150 токенов в день)
   - NightCafe (бесплатные кредиты)
   - Midjourney в Discord (бесплатный триал)
   - Ideogram.ai или Flux через Hugging Face
2. Введи примерно такой промпт (копируй и вставляй):
---
   pixel art tower defense tileset sprite sheet, top-down 2D, 128x128 pixels per tile, clean grid, grass tiles, dirt road tiles, stone paths, bushes, rocks, flowers, hex and square variations, retro 16-bit style, transparent background, no text, perfect alignment --ar 8:5 --stylize 250 --v 6
 ---


3. Сгенерируй 4–10 вариантов → выбери лучший → скачай в PNG
4. Убедись, что тайлы ровные (128×128 + 1 px padding между ними)

**Вариант 3 — Бесплатные альтернативы (itch.io, OpenGameArt)**
- https://itch.io/game-assets/free → поиск: "tower defense tileset" или "pixel art tileset free"
Примеры: "Free Tower Defense Tileset" от Cainos, "Pixel Farm Tileset" от Szadi Art
- https://opengameart.org → поиск: "tower defense sprite sheet" или "top down tileset"
Популярные: "Tower Defense 300 Tiles/Sprites", "LPC Style Farm Expansion"

**Вариант 4 — Unity Asset Store (если хочешь готовое без нарезки)**
1. В Unity: **Window** → **Asset Store**
2. Поиск: **free tower defense tileset** или **pixel art td tiles**
3. Скачай любой бесплатный набор (например, "2D Tower Defense - Free Pack")

#### 3. Импорт и нарезка спрайтшита
1. В Unity → окно **Project** → правой кнопкой на **Assets** → **Create** → **Folder** → назови **Sprites**
2. Двойной клик → открой папку **Sprites**
3. Перетащи **один большой PNG-спрайтшит** из папки на компьютере прямо в **Assets/Sprites**

4. Кликни на него один раз → в **Inspector**:
- Texture Type → **Sprite (2D and UI)**
- Sprite Mode → **Multiple**
- Pixels Per Unit → **128**
- Filter Mode → **Point (no filter)**
- Compression → **None**
→ нажми **Apply**

5. Нажми кнопку **Sprite Editor**
6. В Sprite Editor → **Slice**:
- Type → **Grid By Cell Size**
- Pixel Size → **X: 129**   **Y: 129**   (128 + 1 px padding!)
- Pivot → **Center** (0.5, 0.5)
- Нажми **Slice**
7. Проверь, что каждый тайл в отдельном синем квадрате → **Apply** → закрой окно

#### 4. Создаём Tilemap слои
1. В **Hierarchy** → правой кнопкой → **2D Object** → **Tilemap** → **Rectangular**
→ появятся два объекта: **Grid** и дочерний **Tilemap**
2. Переименуй дочерний Tilemap в **Ground**
3. Снова правой кнопкой на **Grid** → **2D Object** → **Tilemap** → **Rectangular**
4. Переименуй новый Tilemap в **Path**

**Зачем два слоя?**  
Ground — фон (трава, декор), Path — дорога (по ней пойдут враги). Так дорога всегда поверх травы.

#### 5. Настраиваем Tile Palette
1. **Window** → **2D** → **Tile Palette** (если не видно — **View** → **Tile Palette**)
2. В Tile Palette нажми **Create New Palette** → имя **GroundPalette** → **Create**
3. Перетащи из **Sprites** все тайлы травы/земли/камней/кустов в палитру → каждый раз жми **Create Tile** → OK
4. Аналогично создай **PathPalette** и перетащи туда все дорожные тайлы


---

### Альтернативный вариант — массовая передача тайлов в палитру (самый удобный в 2024–2026)

1. Откройте Tile Palette  
   **Window → 2D → Tile Palette**  
   (если окно не видно → **View → Tile Palette** или просто перетащите вкладку в удобное место)

2. Создайте палитру  
   В Tile Palette нажмите кнопку **Create New Palette…**  
   → в появившемся окне напишите имя → **GroundPalette**  
   → нажмите **Create**  
   (Unity создаст папку Assets/TilePalettes/GroundPalette и файл .asset)

3. **Массовая передача всех тайлов травы/земли одним движением**  
   - В окне **Project** зайдите в папку **Sprites** (или куда вы нарезали спрайты)  
   - Отфильтруйте или вручную выделите **все нужные тайлы травы / земли / декора**  
     (самый простой способ: зажмите Ctrl и кликайте по именам, которые начинаются на grass_, ground_, bush_, rock_, flower_ и т.д.)  
   - **Перетащите сразу всю группу выделенных спрайтов** в область Tile Palette (в пустую часть палитры)  
   - Unity автоматически создаст Tile-ассеты для всех перетащенных спрайтов  
     (появится прогресс-бар, если файлов много — 20–100 штук)

   → После завершения все тайлы появятся в палитре как готовые кисточки

4. Повторите то же самое для дорожных тайлов  
   - Создайте новую палитру: **Create New Palette → PathPalette → Create**  
   - Выделите в Project все road_, path_, bridge_, corner_ и т.д.  
   - Перетащите всей группой в PathPalette

### Что делать, если кистью **не рисует** (самые частые проблемы и быстрые решения)

| Симптом | Причина | Как исправить (по приоритету) |
|-------|--------|-------------------------------|
| Курсор меняется на запрещающий знак (круг с чертой) | Нет активного Tilemap | В Tile Palette нажмите кнопку **Active Tilemap** (иконка сетки) → выберите **Ground** или **Path** |
| Кисть рисует, но тайлы не появляются | Tilemap не выбран в Hierarchy | В Hierarchy кликните на объект **Ground** или **Path** (чтобы он был подсвечен синим) |
| Рисует, но тайлы смещены / не по сетке | Cell Size в Grid не 1×1×1 | Выделите объект **Grid** → Inspector → Cell Size → поставьте **1 / 1 / 1** |
| Появляются зазоры 1 px между тайлами | Padding не компенсирован | Grid → **Cell Gap** → X: -0.0078125  Y: -0.0078125  Z: 0  (1/128) |
| Кисть рисует прозрачные квадраты | Tile имеет прозрачный фон или неправильный pivot | Вернитесь в Sprite Editor → каждый тайл → Pivot → **Center** (0.5, 0.5) → Apply |
| После перезапуска Unity палитра пустая | Tile-ассеты не сохранены | После перетаскивания нажмите **Ctrl+S** (сохранить проект) |
| Кисть рисует только один тайл, а не группу | Brush не Tile Brush | В Tile Palette слева убедитесь, что выбрана иконка **Brush** (не Pencil, не Eraser и т.д.) |

### Стандартные настройки, которые используют в большинстве инди-студий (2024–2026)

Эти значения помогут сразу делать «по-взрослому», чтобы потом не переделывать.

**Grid (объект в Hierarchy)**

- Cell Size → **1 × 1 × 1**
- Cell Gap → **0 × 0 × 0**  (или -0.0078125 × -0.0078125 × 0 если есть padding 1 px)
- Cell Layout → **Rectangle**
- Cell Swizzle → **XYZ** (по умолчанию)

**Каждый Tilemap (Ground, Path, Decoration и т.д.)**

- Tile Anchor → **(0.5, 0.5, 0)**
- Tilemap Renderer → Mode → **Individual** (если нужны разные сортировки)
- Sorting Layer → **Default** или создайте **Background / Midground / Foreground**
- Order in Layer → Ground = 0, Path = 1, Decoration = 2 и т.д.

**Tile Palette**

- Grid → **Automatic** (или Manual, если хотите точно контролировать)
- Brush Spacing → **X:1  Y:1**
- Show Grid → включено (удобно видеть клетки)

**Общие рекомендации проекта**

- Edit → Project Settings → Editor → Sprite Packer Mode → **Disabled** (если используете Tilemap)
- Edit → Project Settings → 2D → **Sprite Atlas** → Create Sprite Atlas для всех тайлов (оптимизация на билде)
- Pixels Per Unit всех спрайтов → **128** (или 64, если тайлы 64×64) — единое значение на весь проект

**Быстрый чек-лист перед рисованием карты**

1. Grid → Cell Size = 1×1×1
2. Tilemap Ground и Path подсвечены и выбраны как Active
3. В палитре видны все тайлы
4. Курсор в Scene окне — нормальная кисть (не запрещающий знак)
5. Ctrl + S после любого большого изменения

---

#### 6. Рисуем карту
1. В Tile Palette выбери **GroundPalette**
2. В Scene окне зажми левую кнопку мыши и води → заливай всю видимую область травой/землёй
3. Переключи палитру на **PathPalette**
4. Нарисуй дорогу:
- Начало — левый нижний угол экрана
- Конец — правый верхний угол
- Длина ≈ 120–160 тайлов (12–18 поворотов, чтобы было интересно)
- Совет: зажми левую кнопку и води — дорога рисуется непрерывно

**Результат дня 2**  

У тебя есть готовая карта: тёмно-зелёный фон, трава/земля, извилистая дорога из тайлов.  
Всё ровно, без зазоров, пиксели чёткие. Можно переходить к waypoints!

---

### День 3 — Waypoints (точки пути для врагов)

**Цель дня:**  
Создать визуально редактируемые точки пути, по которым будут двигаться враги.  
Сделать это так, чтобы:
- точки легко двигались мышкой в редакторе
- путь можно было быстро менять при тестировании уровней
- данные пути хранились отдельно от сцены (чтобы можно было переиспользовать на разных сценах/уровнях)

#### 1. Создаём контейнер для всех точек пути
1. В окне **Hierarchy** (слева) кликните правой кнопкой мыши в пустом месте  
2. Выберите **Create Empty**  
3. В поле имени (вверху Hierarchy) напишите **Waypoints** → Enter

**Зачем отдельный пустой объект?**  
- Все точки пути будут дочерними → их легко включать/выключать одним кликом  
- В инспекторе можно будет быстро увидеть количество точек (Children count)  
- Удобно применять скрипты/теги/слои ко всей группе сразу

#### 2. Создаём 16 точек пути (WP0 – WP15)
1. Выделите объект **Waypoints** (кликните один раз)  
2. Правой кнопкой → **Create Empty**  
3. Переименуйте в **WP0**  
4. Повторите шаги 2–3 ещё 15 раз → получите WP1, WP2, …, WP15

**Профессиональный совет (как делают в студиях):**
- Не создавайте вручную 50 точек — лучше сделайте 15–20, а потом (на следующем этапе) добавьте скрипт, который автоматически создаёт нужное количество  
- Называйте точки **WP + номер** (WP00, WP01…) — удобно сортировать и искать

#### 3. Делаем все точки дочерними Waypoints
1. Выделите все WP0–WP15:  
   зажмите **Shift** и кликайте по каждому (или зажмите левую кнопку и обведите рамкой)  
2. Перетащите выделенные объекты **на объект Waypoints** в Hierarchy  
   → они станут дочерними (появится отступ слева)

**Зачем это важно?**  
- Все точки видны в иерархии как одна группа  
- Можно двигать весь путь целиком (перетащить Waypoints)  
- Легко удалять/добавлять точки без путаницы

#### 4. Расставляем точки точно по центру дороги
1. Нажмите клавишу **W** → включится инструмент **Move** (стрелки)  
2. Включите **Snap to Grid** (очень важно!):  
   - В верхней панели инструментов нажмите иконку **магнита** (Snap Settings)  
   - Или Edit → Snap Settings → Move → установите **X: 1, Y: 1, Z: 0**  
   - Включите галочку **Snap** (или используйте горячую клавишу **Ctrl** при движении)

3. По очереди выделяйте каждый WP и ставьте его **точно в центр тайла дороги**:
   - WP0 — самый первый тайл начала пути (левый нижний угол)  
   - WP1, WP2… — следующие повороты и прямые участки  
   - WP15 — последний тайл (правый верхний угол, где враги исчезают)

**Профессиональные правила расстановки (как в инди-студиях):**
- Центр тайла = координаты кратные 0.5 (например 4.5, 7.5, 0)  
  (если PPU = 128 и Cell Size = 1 → центр тайла = X.5 / Y.5)
- Держите Z = 0 у всех точек (2D игра)
- Делайте путь **не слишком прямым** — 12–18 поворотов для интересного геймплея
- Оставляйте запас (1–2 лишние точки в конце) — потом можно удалить

#### 5. Создаём ScriptableObject для хранения пути
1. В окне **Project** правой кнопкой на **Assets** → **Create** → **ScriptableObject**  
2. Назовите файл **LevelPath** → Enter

**Зачем ScriptableObject, а не MonoBehaviour на сцене?**  
- Данные пути можно переиспользовать на разных сценах/уровнях  
- Легко менять путь без открытия сцены (в Assets)  
- Можно сделать несколько LevelPath.asset (Level1, Level2, BossLevel)  
- В инди-проектах это стандартный паттерн для конфигов уровней

#### 6. Создаём скрипт LevelPath.cs
1. В Project правой кнопкой → **Create** → **C# Script**  
2. Назовите **LevelPath**  
3. Откройте скрипт (двойной клик) и замените содержимое на:

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "LevelPath", menuName = "TD/LevelPath")]
public class LevelPath : ScriptableObject
{
    public Transform[] points;
}

```

Зачем именно Transform[]?

Позволяет видеть и двигать точки прямо в редакторе
Transform.position — это то, что нужно для движения врагов
Легко расширять (добавить скорость, поворот, масштаб и т.д.)

#### 7. Заполняем массив точек в LevelPath.asset

В Project найдите LevelPath.asset → дважды кликните (откроется Inspector)
В поле Points нажмите на кружок справа от Size → поставьте 16 (или больше)
По очереди перетащите из Hierarchy объекты WP0 → WP15 в слоты массива Points:
Element 0 → WP0
Element 1 → WP1
…
Element 15 → WP15

---
### Зачем нужны waypoints в Tower Defense игре (подробное объяснение)

Waypoints (или "точки пути") — это простые пустые GameObject в Unity, которые служат маркерами для движения врагов по карте. Они определяют траекторию, по которой враги будут ходить от старта до финиша. Давай разберём, зачем они нужны, шаг за шагом.

1. **Основная цель: направлять движение врагов**  
   В Tower Defense враги должны идти по фиксированной дороге, чтобы игроки могли ставить башни вдоль пути и атаковать их. Без waypoints враги просто шли бы в случайном направлении или застревали.  
   Waypoints работают как "чекпоинты": враг смотрит на следующую точку, вычисляет направление (vector = nextPoint.position - currentPosition), нормализует его и двигается с скоростью (transform.position += direction * speed * Time.deltaTime). Когда враг доходит до точки (расстояние < 0.05), он переключается на следующую. Это простой и надёжный способ создать патролинг.  
   Без них пришлось бы использовать сложные вещи, как NavMesh (для AI), но для TD с фиксированной дорогой waypoints проще и быстрее.

2. **Визуальная редактируемость**  
   Waypoints — это объекты в сцене, которые ты видишь в редакторе. Ты можешь перетаскивать их мышкой, чтобы изменить путь. Например, если дорога изменилась, просто передвинь точки. Это удобно для дизайнеров уровней — можно тестировать разные маршруты без кода.

3. **Гибкость для геймдизайна**  
   - Позволяют делать повороты, петли, развилки (если добавить логику ветвления).  
   - Можно добавлять эффекты: на точке WP5 враг замедляется, на WP10 — спавнится босс.  
   - Легко интегрировать с другими системами: башни могут "видеть" путь, чтобы расставляться рядом.

4. **Оптимизация и производительность**  
   - Простой цикл Update() с Vector3.Distance — очень быстро, даже для 100 врагов.  
   - Не требует тяжёлого AI (как A* или NavMesh), что экономит CPU в мобильных играх.

5. **Почему их так много (15+ в туториале)?**  
   - Для извилистой дороги: если путь прямой, хватит 2–3 точек. Но в TD дорога должна быть длинной и петляющей, чтобы враги шли 30–60 секунд, давая время на башни. Каждый поворот или прямой участок — отдельная точка. Для карты 20x20 тайлов с 12–18 поворотами нужно 15–20 точек.  
   - Запас на тестирование: если путь короткий, враги приходят слишком быстро — игра неинтересная. Много точек позволяют экспериментировать.  
   - Масштабируемость: в большом проекте уровни имеют 50–100 точек. В туториале 16 — это стартовый минимум, чтобы показать, как это работает на практике.  
   - Почему не меньше: короткий путь = короткая игра. В реальных TD (Bloons TD, Kingdom Rush) пути имеют десятки сегментов.

### Почему LevelPath принимает Transform только с префабов (и как это работает)

Это распространённая путаница в Unity. LevelPath.cs имеет массив public Transform[] points — это ссылки на Transform компоненты объектов. Но ScriptableObject (SO) — это asset-файл, который живёт в проекте, а не в сцене. Unity имеет строгое правило: SO не может держать ссылки на объекты из сцены (scene objects), потому что сцена может быть закрыта, удалена или изменена, а SO должен работать всегда.

- **Почему "только с префабов"?**  
  - Когда ты перетаскиваешь Transform из Hierarchy в поле SO, Unity проверяет: если объект — из сцены (не префаб), то появляется ошибка "Type Mismatch" или поле не принимает.  
  - Префаб — это тоже asset (файл .prefab), так что ссылка на его Transform разрешена. Если ты сделаешь префабы из WP0–WP15, то перетаскивание сработает. Но это костыль — 16 префабов для точек? Неудобно.

- **Зачем такое ограничение?**  
  - SO должен быть независимым: если ты скопируешь проект на другой компьютер или закроешь сцену, ссылки на scene objects станут null или missing.  
  - Это защищает от ошибок: проект не сломается, если сцена изменится.

### Как сделать универсально для разных уровней с автоматическим подхватом

Чтобы сделать систему гибкой (разные уровни, автоматический сбор точек), используй Vector3[] вместо Transform[]. Это позволит хранить только позиции (координаты), а не ссылки на объекты. Точки WP остаются в сцене для визуального редактирования, а SO хранит данные. Для автоматического подхвата добавим custom editor с кнопкой "Update from Scene".

1. **Измените LevelPath.cs на Vector3[]**  
   Откройте скрипт и замените на это:

   using UnityEngine;

   [CreateAssetMenu(fileName = "LevelPath", menuName = "TD/LevelPath")]
   public class LevelPath : ScriptableObject
   {
       public Vector3[] points;
   }

   Зачем?  
   Vector3 — примитив (числа X, Y, Z), SO может хранить их без проблем. Нет ссылок на объекты, так что нет ограничений.

2. **Измените EnemyMovement.cs (если есть)**  
   В скрипте движения врагов замените Transform[] на Vector3[]:
   - private Vector3[] points => path.points;  
   - Vector3 targetPos = points[currentPointIndex + 1];  

   Это работает так же, но использует позиции, а не Transform.

3. **Добавьте custom editor для автоматического подхвата**  
   Создайте папку Editor в Assets (если нет).  
   В Editor создайте C# Script — LevelPathEditor.cs.  
   Вставьте этот код:
```csharp
   #if UNITY_EDITOR  
   using UnityEngine;  
   using UnityEditor;  

   [CustomEditor(typeof(LevelPath))]  
   public class LevelPathEditor : Editor  
   {  
       public override void OnInspectorGUI()  
       {  
           DrawDefaultInspector();  

           LevelPath path = (LevelPath)target;  
           if (GUILayout.Button("Update Path from Scene"))  
           {  
               GameObject waypointsGO = GameObject.Find("Waypoints");  
               if (waypointsGO == null)  
               {  
                   EditorUtility.DisplayDialog("Ошибка", "Не найден Waypoints!", "OK");  
                   return;  
               }  

               Transform[] transforms = waypointsGO.GetComponentsInChildren<Transform>();  
               path.points = new Vector3[transforms.Length];  
               for (int i = 0; i < transforms.Length; i++)  
               {  
                   path.points[i] = transforms[i].position;  
               }  

               EditorUtility.SetDirty(path);  
               EditorUtility.DisplayDialog("Готово", $"Обновлено {path.points.Length} точек", "OK");  
               }  
       }  
   }  
   #endif
```
   Зачем?  
   В Inspector LevelPath.asset появится кнопка "Update Path from Scene".  
   Нажми — она автоматически соберёт позиции всех дочерних WP из Waypoints.  
   Это стандарт в студиях: дизайнеры редактируют точки в сцене, а кнопка обновляет SO.

4. **Как использовать на разных уровнях**  
   - Для Level1 — создай Level1.scene, поставь свои Waypoints, обнови Level1_Path.asset кнопкой.  
   - Для Level2 — новая сцена, новые точки, новый asset (Assets → Create → TD → LevelPath).  
   - В скрипте врага: [SerializeField] private LevelPath path; — перетащи нужный asset в инспекторе.  
   - Для автоматического подхвата: в GameManager на старте сцены найди Waypoints и обнови SO, если нужно.


---


#### Профессиональный совет:

В реальных проектах делают кнопку "Collect from Children" в custom editor
(чтобы не перетаскивать 50 точек вручную)
Если интересно — скажите, добавлю такой скрипт в следующий день

Результат дня 3

В Hierarchy есть объект Waypoints с 16 дочерними точками WP0–WP15
Все точки стоят точно по центру дороги
Есть файл LevelPath.asset, в котором массив из 16 ссылок на эти точки
Теперь путь можно легко редактировать мышкой → изменения сразу видны в инспекторе LevelPath

Проверка:

Перетащите любую точку WP в сторону → посмотрите в LevelPath.asset — координаты обновились
Нажмите Play → ничего не должно происходить (врагов пока нет)
Всё работает → день пройден!

Готовы к Дню 4 (движение врага по пути)?

---

### День 4 — Префаб первого врага (Slime)

**Цель дня:**  
Создать готовый шаблон (префаб) врага — зелёного слизня.  
Этот префаб будет использоваться для спавна всех врагов в волнах.  
Сегодня мы только подготовим внешний вид и коллайдер — движение добавим завтра.

**Результат дня:**  
В папке Prefabs/Enemies появится синий объект Slime.prefab, готовый к клонированию.

#### 1. Создаём пустой объект для врага

1. В окне **Hierarchy** (слева) щёлкните правой кнопкой мыши в пустом месте.  
2. Выберите **Create Empty**.  
3. Появится объект GameObject.  
4. Кликните по нему дважды (или нажмите F2) и переименуйте в **Slime**.  
5. Нажмите Enter.

**Зачем пустой объект?**  
Это будет корневой объект врага. Все компоненты (спрайт, коллайдер, физика) добавляются к нему.  
Так структура остаётся чистой и легко расширяемой (можно добавить анимацию, звук, здоровье и т.д.).

#### 2. Добавляем Sprite Renderer — чтобы враг был виден

1. Выделите объект **Slime** в Hierarchy.  
2. В окне **Inspector** (справа) внизу нажмите кнопку **Add Component**.  
3. В поисковой строке напишите **Sprite Renderer** и выберите его.  
4. Компонент появится.  
5. В поле **Sprite** нажмите маленький кружок справа — откроется окно выбора.  
6. Перейдите в папку **Sprites** → найдите спрайт с именем **slime**, **slime_green** или похожим (из вашего спрайтшита Kenney).  
7. Кликните по нему два раза или перетащите в поле Sprite.

**Зачем нужен Sprite Renderer?**  
Это компонент, который рисует 2D-картинку на экране.  
Без него враг будет невидимым, даже если у него есть спрайт в файлах.

**Совет:**  
Если спрайт выглядит слишком большим/маленьким — измените **Pixels Per Unit** спрайта в Inspector на 128 (как у остальных тайлов).

#### 3. Добавляем Circle Collider 2D — для обнаружения и попаданий

1. Снова нажмите **Add Component**.  
2. В поиске напишите **Circle Collider 2D** и добавьте.  
3. В Inspector найдите галочку **Is Trigger** и поставьте её (должна быть включена).  
4. В поле **Radius** установите значение **0.4** или **0.5** (можно подвигать ползунок, чтобы коллайдер примерно совпадал с размером спрайта).

**Зачем Circle Collider 2D?**  
- Позволяет башням находить врага в радиусе атаки (Physics2D.OverlapCircleAll).  
- Позволяет пулям попадать по врагу (OnTriggerEnter2D).  
**Is Trigger = true** — значит, физика не будет отталкивать объекты, а просто сообщать о касании (это стандарт для врагов в TD).  

**Почему круглый коллайдер?**  
Форма врага круглая/овальная — круг проще и точнее покрывает спрайт, чем квадрат.

#### 4. Добавляем Rigidbody 2D — для работы триггеров

1. **Add Component** → в поиске **Rigidbody 2D**.  
2. В Inspector найдите поле **Body Type** и выберите **Kinematic**.  
3. **Gravity Scale** поставьте **0** (если там другое число — сотрите и напишите 0).

**Зачем Rigidbody 2D нужен, если мы двигаем врага скриптом?**  
Unity требует Rigidbody на объекте с коллайдером, если вы хотите использовать триггеры (OnTriggerEnter2D / OnTriggerStay2D).  
**Kinematic** — значит: «Я сам управляю движением, не применяй ко мне физику и гравитацию».  
Gravity Scale = 0 — чтобы враг не падал вниз.

#### 5. Сохраняем объект как префаб

1. В Hierarchy найдите объект **Slime** (он должен быть выделен).  
2. Перетащите его мышкой в окно **Project** → в папку **Assets**.  
3. Если папки Prefabs нет — создайте её: правой кнопкой на Assets → **Create** → **Folder** → назовите **Prefabs**.  
4. Внутри Prefabs создайте подпапку **Enemies** (правой кнопкой → Create → Folder → Enemies).  
5. Перетащите Slime именно в **Assets/Prefabs/Enemies**.  
6. После перетаскивания объект в Hierarchy станет **синим** — это значит, он теперь префаб.

**Зачем делать префаб?**  
Префаб — это шаблон. Завтра мы будем создавать копии врагов командой Instantiate(SlimePrefab).  
Если потом захотите изменить врага (цвет, размер, звук) — измените префаб один раз, и все копии обновятся автоматически.

#### 6. Удаляем временный объект из сцены

1. В Hierarchy найдите объект **Slime** (он синий).  
2. Щёлкните правой кнопкой → **Delete**.  
Или выделите и нажмите клавишу **Delete**.

**Зачем удалять?**  
Сцена должна быть чистой. Префаб уже сохранён в проекте — экземпляр в сцене нам пока не нужен.

**Проверка результата дня 4**

- В папке **Assets/Prefabs/Enemies** лежит синий файл **Slime.prefab**.  
- Дважды кликните по нему — откроется режим редактирования префаба: виден спрайт слизня, коллайдер (зелёный круг), Rigidbody.  
- Всё настроено правильно:  
  - Sprite Renderer показывает картинку  
  - Circle Collider 2D с Is Trigger = true и радиусом ~0.45  
  - Rigidbody 2D — Kinematic, Gravity = 0

**Что нового появилось?**  
- Готовый префаб врага, который можно клонировать тысячи раз.  
- Теперь у нас есть карта (День 2), точки пути (День 3) и первый враг — завтра он поедет!

На этом День 4 завершён.

---

### День 5 — Движение по waypoints

Создайте скрипт **EnemyMovement.cs**

```csharp
using UnityEngine;

public class EnemyMovement : MonoBehaviour
{
    [SerializeField] private LevelPath path;
    [SerializeField] private float speed = 2f;

    private int currentPointIndex = 0;
    private Transform[] points => path.points;

    private void Start()
    {
        if (points.Length == 0 || path == null)
        {
            Debug.LogError("Путь не назначен!", this);
            enabled = false;
            return;
        }

        // Ставим врага на стартовую точку
        transform.position = points[0].position;
    }

    private void Update()
    {
        if (currentPointIndex >= points.Length - 1)
        {
            // Дошёл до конца — здесь позже будет урон по базе
            Destroy(gameObject);
            return;
        }

        Vector3 targetPos = points[currentPointIndex + 1].position;
        Vector3 direction = (targetPos - transform.position).normalized;

        transform.position += direction * speed * Time.deltaTime;

        // Достигли точки?
        if (Vector3.Distance(transform.position, targetPos) < 0.05f)
        {
            currentPointIndex++;
            transform.position = targetPos; // точная фиксация
        }
    }
}
```

1. Прикрепите скрипт к префабу Slime  
2. Перетащите LevelPath.asset в поле **Path**

**Результат дня 5**  
Если перетащить Slime на сцену и нажать Play — он должен пойти по всему пути и исчезнуть в конце.

---

### День 6 — Здоровье и HP-бар

Создайте скрипт **EnemyHealth.cs**

```csharp
using UnityEngine;

public class EnemyHealth : MonoBehaviour
{
    [SerializeField] private float maxHealth = 80f;
    private float currentHealth;

    [SerializeField] private GameObject deathEffectPrefab; // позже

    private void Awake()
    {
        currentHealth = maxHealth;
    }

    public void TakeDamage(float amount)
    {
        currentHealth -= amount;
        if (currentHealth <= 0)
        {
            Die();
        }
    }

    private void Die()
    {
        // Здесь позже: золото, эффект смерти
        Destroy(gameObject);
    }

    public float GetHealthNormalized() => currentHealth / maxHealth;
}
```

1. Прикрепите к префабу Slime  
2. Создайте дочерний объект **Canvas** → переименуйте в **HealthBar**  
   → Render Mode → **World Space**  
   → Scale → 0.01, 0.01, 0.01  
   → Width 100, Height 10

3. В Canvas добавьте Image → назовите **Fill**  
   → Color зелёный  
   → Image Type → Filled → Fill Method → Horizontal

4. Создайте скрипт **HealthBarUI.cs**

```csharp
using UnityEngine;
using UnityEngine.UI;

public class HealthBarUI : MonoBehaviour
{
    [SerializeField] private Image fillImage;
    private EnemyHealth health;

    private void Awake()
    {
        health = GetComponentInParent<EnemyHealth>();
    }

    private void LateUpdate()
    {
        if (health == null) return;

        fillImage.fillAmount = health.GetHealthNormalized();

        // Поворот к камере
        transform.rotation = Camera.main.transform.rotation;
    }
}
```

5. Прикрепите скрипт к объекту HealthBar → перетащите Fill в поле

**Результат дня 6**  
У врага есть здоровье и полоска HP над головой.
