### День 19 — Основной HUD (золото, жизни, волна)

**Цель дня:** Создать постоянный интерфейс, который показывает текущее состояние игры.

1. Откройте сцену Main.unity  
2. Если Canvas ещё нет — Hierarchy → UI → Canvas → назовите **UICanvas**  
   - Canvas Scaler → UI Scale Mode: Scale With Screen Size  
   - Reference Resolution: 1920 × 1080  
   - Screen Match Mode: Match Width Or Height → Match: 0.5

3. В UICanvas создайте 4 дочерних TextMeshPro - Text (UGUI):

   | Название       | Anchor              | Pos X / Pos Y   | Font Size | Цвет       | Текст по умолчанию          |
   |----------------|---------------------|------------------|-----------|------------|------------------------------|
   | GoldText       | Top Left            | 20 / -20        | 48        | #FFD700    | Gold: 350                    |
   | LivesText      | Top Right           | -20 / -20       | 48        | #FF4444    | Lives: 20                    |
   | WaveText       | Top Center          | 0 / -20         | 42        | #FFFFFF    | Wave: 1 / 12                 |
   | TimerText      | Top Center          | 0 / -80         | 36        | #AAAAAA    | Next wave: 8                 |

4. Создайте скрипт **UIManager.cs** и прикрепите его к UICanvas

```csharp
using UnityEngine;
using TMPro;

public class UIManager : MonoBehaviour
{
    [Header("Тексты")]
    public TextMeshProUGUI goldText;
    public TextMeshProUGUI livesText;
    public TextMeshProUGUI waveText;
    public TextMeshProUGUI timerText;

    private WaveSpawner waveSpawner;
    private BuildManager buildManager;

    private void Awake()
    {
        waveSpawner = FindObjectOfType<WaveSpawner>();
        buildManager = FindObjectOfType<BuildManager>();
    }

    private void Update()
    {
        if (goldText) goldText.text = $"Gold: {buildManager.gold}";
        if (livesText) livesText.text = $"Lives: {buildManager.lives}";
        if (waveText) waveText.text = $"Wave: {waveSpawner.currentWave} / 12";
        if (timerText && waveSpawner.countdown > 0)
            timerText.text = $"Next wave: {Mathf.Ceil(waveSpawner.countdown)}";
        else if (timerText)
            timerText.text = "";
    }
}
```

5. В инспекторе UIManager перетащите все 4 TextMeshPro в соответствующие поля.

6. В **BuildManager.cs** добавьте поля:

```csharp
public int gold = 350;
public int lives = 20;
```

**Контрольная проверка дня 19**  
Play → вверху экрана видно золото 350, жизни 20, волна 1/12, таймер обратного отсчёта.

---

### День 20 — Экономика (получение и трата золота)

**Цель дня:** Связать убийства врагов с золотом + правильная трата.

1. В **EnemyHealth.cs** добавьте:

```csharp
[SerializeField] private int goldReward = 6;

public void TakeDamage(float amount)
{
    currentHealth -= amount;
    if (currentHealth <= 0)
    {
        if (BuildManager.main != null)
            BuildManager.main.AddGold(goldReward);
        
        Die();
    }
}
```

2. В **BuildManager.cs** добавьте методы:

```csharp
public void AddGold(int amount)
{
    gold += amount;
    // Можно добавить эффект +текст позже
}

public bool SpendGold(int amount)
{
    if (gold >= amount)
    {
        gold -= amount;
        return true;
    }
    return false;
}
```

3. В **TowerController.Upgrade()** используйте SpendGold (уже есть в предыдущем коде)

4. В **BuildManager.TryPlaceTower()** замените

```csharp
if (SpendGold(selectedTowerData.baseCost))
```

**Контрольная проверка дня 20**  
Убейте 5 врагов → золото должно увеличиться на 5 × 6 = 30.  
Постройте башню → золото уменьшится на 80 (или на стоимость выбранной башни).

---

### День 21 — Урон по жизням (враг дошёл до конца)

**Цель дня:** Реализовать потерю жизней и Game Over.

1. В **EnemyMovement.cs** добавьте проверку конца пути:

```csharp
private void Update()
{
    // ... существующий код движения ...

    if (currentPointIndex >= points.Length - 1)
    {
        // Дошёл до конца
        if (BuildManager.main != null)
        {
            BuildManager.main.TakeLife();
        }
        Destroy(gameObject);
        return;
    }
}
```

2. В **BuildManager.cs** добавьте:

```csharp
public void TakeLife()
{
    lives--;
    if (lives <= 0)
    {
        GameOver();
    }
}

private void GameOver()
{
    Debug.Log("GAME OVER - Кристалл разрушен!");
    Time.timeScale = 0; // пока просто остановка времени
    // Позже здесь будет экран поражения
}
```

**Контрольная проверка дня 21**  
Пропустите врага до конца пути → Lives уменьшится на 1.  
Если довести до 0 → в консоли "GAME OVER" и игра останавливается.

---

### День 22 — Экраны победы и поражения

**Цель дня:** Простые экраны Win / Lose.

1. В UICanvas создайте два Panel:

   - **GameOverPanel** (неактивен)  
     - Image (полупрозрачный чёрный фон)  
     - TextMeshPro "Монстры победили!" (красный, size 72)  
     - Button "Restart" (ниже текста)

   - **VictoryPanel** (неактивен)  
     - TextMeshPro "Кристалл спасён!" (золотой, size 72)  
     - TextMeshPro "Волны пройдены: 12/12"  
     - Button "Играть снова"

2. В **WaveSpawner.cs** добавьте:

```csharp
public GameObject victoryPanel;
public GameObject gameOverPanel;

private int maxWaves = 12;

// в Update, когда currentWave > maxWaves
if (currentWave > maxWaves)
{
    if (victoryPanel) victoryPanel.SetActive(true);
    Time.timeScale = 0;
}
```

3. В **BuildManager.GameOver()** замените Debug.Log на:

```csharp
if (gameOverPanel) gameOverPanel.SetActive(true);
Time.timeScale = 0;
```

4. На кнопке Restart обеих панелей добавьте OnClick → SceneManager.LoadScene("Main");

**Контрольная проверка дня 22**  
Пройдите 12 волн → появляется экран победы.  
Потеряйте все жизни → появляется экран поражения.

---

### День 23 — Продажа башен

**Цель дня:** Добавить возможность продавать построенные башни.

1. В префаб каждой башни добавьте дочерний Canvas → World Space  
   - Scale: 0.01 × 0.01 × 0.01  
   - Width 100, Height 40  
   - Назовите **SellButtonCanvas** (неактивен по умолчанию)

2. В Canvas добавьте Button → Text "Sell"  
   - OnClick → вызов метода SellTower на башне

3. В **TowerController.cs** добавьте:

```csharp
[SerializeField] private GameObject sellButtonCanvas;

private void OnMouseEnter()
{
    if (sellButtonCanvas) sellButtonCanvas.SetActive(true);
}

private void OnMouseExit()
{
    if (sellButtonCanvas) sellButtonCanvas.SetActive(false);
}

public void Sell()
{
    int refund = Mathf.RoundToInt(data.baseCost * 0.65f); // 65% возврата
    // Можно учитывать уровень улучшения, но пока просто базовая цена
    BuildManager.main.AddGold(refund);
    Destroy(gameObject);
}
```

4. На кнопку Sell → OnClick → TowerController → Sell()

**Контрольная проверка дня 23**  
Наведите мышь на построенную башню → появляется кнопка Sell.  
Нажмите → башня исчезает, золото +65% от стоимости.

---

### День 24 — Финальная сборка прототипа Месяца 2 + тест

**Цель дня:** Убедиться, что всё работает вместе + мелкие фиксы.

1. Проверьте и исправьте типичные проблемы:

   - Враг дошёл → жизни уменьшаются → экран GameOver
   - Волна 12 → экран Victory
   - Строительство → только на Buildable слое
   - Улучшение → тратит золото и меняет статы
   - Продажа → возвращает деньги
   - Нет ошибок в консоли при уничтожении объектов

2. Добавьте тестовый лимит волн в WaveSpawner → maxWaves = 12

3. Сделайте Build → PC (File → Build Settings → Add Open Scenes → Build)

**Контрольная проверка дня 24 (и Месяца 2)**  
Запустите собранный .exe →  
- Можно играть полноценную партию до 12 волны  
- Есть магазин, улучшения, продажа, жизни, экраны победы/поражения  
- Нет критических багов (враги не застревают, башни не стреляют в пустоту и т.д.)

---

**Итог Месяца 2**  
У вас теперь есть почти полноценный MVP tower defense:
- 4 типа башен с улучшениями
- Магазин + ghost preview + проверка на размещение
- Экономика (золото за убийства, траты, продажа)
- Жизни и условия победы/поражения
- HUD и экраны