### День 3 — Waypoints (точки пути для врагов)

**Цель дня:**  
Создать визуально редактируемые точки пути, по которым будут двигаться враги.  
Сделать это так, чтобы:  
- точки легко двигались мышкой в редакторе  
- путь можно было быстро менять при тестировании уровней  
- данные пути хранились отдельно от сцены (чтобы можно было переиспользовать на разных сценах/уровнях)

---

#### 1. Создаём контейнер для всех точек пути
1. В окне **Hierarchy** (слева) кликните правой кнопкой мыши в пустом месте  
2. Выберите **Create Empty**  
3. В поле имени (вверху Hierarchy) напишите **Waypoints** → Enter

**Зачем отдельный пустой объект?**  
- Все точки пути будут дочерними → их легко включать/выключать одним кликом на Waypoints  
- В инспекторе сразу видно количество точек (Children count)  
- Удобно применять скрипты, теги, слои или Gizmos-визуализацию ко всей группе сразу  
- В реальных проектах (Bloons TD, Kingdom Rush) такие контейнеры — стандарт для путей, спавн-поинтов, чекпоинтов

**Альтернатива:** можно не создавать родителя, а просто кинуть все точки в корень Hierarchy.  
Плюсы: меньше объектов.  
Минусы: трудно выделить/переместить группу, легко потерять точки среди других объектов. Не рекомендуется.

---

#### 2. Создаём 16 точек пути (WP0 – WP15)
1. Выделите объект **Waypoints** (кликните один раз)  
2. Правой кнопкой → **Create Empty**  
3. Переименуйте в **WP0**  
4. Повторите шаги 2–3 ещё 15 раз → получите WP1, WP2, …, WP15

**Профессиональный совет (как делают в студиях):**  
- Не создавайте вручную 50+ точек — лучше сделайте 15–20, а потом добавьте скрипт, который автоматически создаёт нужное количество  
- Называйте точки **WP + номер** (WP00, WP01…) — удобно сортировать и искать в Hierarchy  
- В больших проектах имена генерируются автоматически (например WP_001, WP_002) или вообще не нужны — точки собираются по порядку в массиве

**Почему именно 16?**  
Для типичной извилистой дороги в TD хватает 12–18 поворотов. 16 точек — хороший запас для тестового уровня (карта ~20×20 тайлов).  
Меньше — путь слишком короткий, враги быстро доходят до конца.  
Больше — сложнее расставить вручную. В реальных играх пути могут иметь 50–100 точек.

---

#### 3. Делаем все точки дочерними Waypoints
1. Выделите все WP0–WP15:  
   зажмите **Shift** и кликайте по каждому (или зажмите левую кнопку и обведите рамкой)  
2. Перетащите выделенные объекты **на объект Waypoints** в Hierarchy  
   → они станут дочерними (появится отступ слева)

**Зачем это важно?**  
- Все точки видны в иерархии как одна группа  
- Можно двигать весь путь целиком (перетащить Waypoints)  
- Легко удалять/добавлять точки без путаницы  
- В инспекторе видно количество детей → сразу понятно, сколько точек в пути

**Альтернатива:** использовать тег "Waypoint" или слой вместо иерархии.  
Плюсы: точки можно разбрасывать по сцене.  
Минусы: нет визуальной группировки, сложнее перемещать весь путь.

---

#### 4. Расставляем точки точно по центру дороги
1. Нажмите клавишу **W** → включится инструмент **Move** (стрелки)  
2. Включите **Snap to Grid** (очень важно!):  
   - В верхней панели инструментов нажмите иконку **магнита** (Snap Settings)  
   - Или Edit → Snap Settings → Move → установите **X: 1, Y: 1, Z: 0**  
   - Включите галочку **Snap** (или используйте горячую клавишу **Ctrl** при движении)

3. По очереди выделяйте каждый WP и ставьте его **точно в центр тайла дороги**:  
   - WP0 — самый первый тайл начала пути (левый нижний угол)  
   - WP1, WP2… — следующие повороты и прямые участки  
   - WP15 — последний тайл (правый верхний угол, где враги исчезают)

**Профессиональные правила расстановки (как в инди-студиях):**  
- Центр тайла = координаты кратные 0.5 (например 4.5, 7.5, 0)  
  (если PPU = 128 и Cell Size = 1 → центр тайла = X.5 / Y.5)  
- Держите Z = 0 у всех точек (2D игра)  
- Делайте путь **не слишком прямым** — 12–18 поворотов для интересного геймплея  
- Оставляйте запас (1–2 лишние точки в конце) — потом можно удалить или использовать для эффектов (замедление, спавн босса)

**Альтернатива:** без Snap (свободное размещение)  
Плюсы: плавный путь.  
Минусы: враги могут "плыть" или застревать на углах тайлов.

---

#### 5. Создаём ScriptableObject для хранения пути
1. В окне **Project** правой кнопкой на **Assets** → **Create** → **ScriptableObject**  
2. Назовите файл **LevelPath** → Enter

**Зачем ScriptableObject, а не MonoBehaviour на сцене?**  
- Данные пути можно переиспользовать на разных сценах/уровнях  
- Легко менять путь без открытия сцены (в Assets)  
- Можно сделать несколько LevelPath.asset (Level1, Level2, BossLevel)  
- В инди-проектах это стандартный паттерн для конфигов уровней (пути, волны врагов, награды)

**Альтернатива:** MonoBehaviour на объекте Waypoints  
Плюсы: всё в сцене, проще для новичков.  
Минусы: не reusable между уровнями, привязан к сцене.

---

#### 6. Создаём скрипт LevelPath.cs
1. В Project правой кнопкой → **Create** → **C# Script**  
2. Назовите **LevelPath**  
3. Откройте скрипт (двойной клик) и замените содержимое на:

```csharp

using UnityEngine;

[CreateAssetMenu(fileName = "LevelPath", menuName = "TD/LevelPath")]
public class LevelPath : ScriptableObject
{
    public Transform[] points;
}

```
==Зачем именно Transform[]?==

> Позволяет видеть и двигать точки прямо в редакторе
> Transform.position — это то, что нужно для движения врагов
> Легко расширять (добавить скорость, поворот, масштаб и т.д.)

---

#### 7. Заполняем массив точек в LevelPath.asset

В Project найдите LevelPath.asset → дважды кликните (откроется Inspector)
В поле Points нажмите на кружок справа от Size → поставьте 16 (или больше)
По очереди перетащите из Hierarchy объекты WP0 → WP15 в слоты массива Points:
* Element 0 → WP0
* Element 1 → WP1
…
* Element 15 → WP15

---
### Зачем нужны waypoints в Tower Defense игре (подробное объяснение)

Waypoints (или "точки пути") — это простые пустые GameObject в Unity, которые служат маркерами для движения врагов по карте. Они определяют траекторию, по которой враги будут ходить от старта до финиша. Давай разберём, зачем они нужны, шаг за шагом.

1. **Основная цель: направлять движение врагов**  
   В Tower Defense враги должны идти по фиксированной дороге, чтобы игроки могли ставить башни вдоль пути и атаковать их. Без waypoints враги просто шли бы в случайном направлении или застревали.  
   Waypoints работают как "чекпоинты": враг смотрит на следующую точку, вычисляет направление (vector = nextPoint.position - currentPosition), нормализует его и двигается с скоростью (transform.position += direction * speed * Time.deltaTime). Когда враг доходит до точки (расстояние < 0.05), он переключается на следующую. Это простой и надёжный способ создать патролинг.  
   Без них пришлось бы использовать сложные вещи, как NavMesh (для AI), но для TD с фиксированной дорогой waypoints проще и быстрее.

2. **Визуальная редактируемость**  
   Waypoints — это объекты в сцене, которые ты видишь в редакторе. Ты можешь перетаскивать их мышкой, чтобы изменить путь. Например, если дорога изменилась, просто передвинь точки. Это удобно для дизайнеров уровней — можно тестировать разные маршруты без кода.

3. **Гибкость для геймдизайна**  
   - Позволяют делать повороты, петли, развилки (если добавить логику ветвления).  
   - Можно добавлять эффекты: на точке WP5 враг замедляется, на WP10 — спавнится босс.  
   - Легко интегрировать с другими системами: башни могут "видеть" путь, чтобы расставляться рядом.

4. **Оптимизация и производительность**  
   - Простой цикл Update() с Vector3.Distance — очень быстро, даже для 100 врагов.  
   - Не требует тяжёлого AI (как A* или NavMesh), что экономит CPU в мобильных играх.

5. **Почему их так много (15+ в туториале)?**  
   - Для извилистой дороги: если путь прямой, хватит 2–3 точек. Но в TD дорога должна быть длинной и петляющей, чтобы враги шли 30–60 секунд, давая время на башни. Каждый поворот или прямой участок — отдельная точка. Для карты 20x20 тайлов с 12–18 поворотами нужно 15–20 точек.  
   - Запас на тестирование: если путь короткий, враги приходят слишком быстро — игра неинтересная. Много точек позволяют экспериментировать.  
   - Масштабируемость: в большом проекте уровни имеют 50–100 точек. В туториале 16 — это стартовый минимум, чтобы показать, как это работает на практике.  
   - Почему не меньше: короткий путь = короткая игра. В реальных TD (Bloons TD, Kingdom Rush) пути имеют десятки сегментов.

### Почему LevelPath принимает Transform только с префабов (и как это работает)

Это распространённая путаница в Unity. LevelPath.cs имеет массив public Transform[] points — это ссылки на Transform компоненты объектов. Но ScriptableObject (SO) — это asset-файл, который живёт в проекте, а не в сцене. Unity имеет строгое правило: SO не может держать ссылки на объекты из сцены (scene objects), потому что сцена может быть закрыта, удалена или изменена, а SO должен работать всегда.

- **Почему "только с префабов"?**  
  - Когда ты перетаскиваешь Transform из Hierarchy в поле SO, Unity проверяет: если объект — из сцены (не префаб), то появляется ошибка "Type Mismatch" или поле не принимает.  
  - Префаб — это тоже asset (файл .prefab), так что ссылка на его Transform разрешена. Если ты сделаешь префабы из WP0–WP15, то перетаскивание сработает. Но это костыль — 16 префабов для точек? Неудобно.

- **Зачем такое ограничение?**  
  - SO должен быть независимым: если ты скопируешь проект на другой компьютер или закроешь сцену, ссылки на scene objects станут null или missing.  
  - Это защищает от ошибок: проект не сломается, если сцена изменится.

### Как сделать универсально для разных уровней с автоматическим подхватом

Чтобы сделать систему гибкой (разные уровни, автоматический сбор точек), используй Vector3[] вместо Transform[]. Это позволит хранить только позиции (координаты), а не ссылки на объекты. Точки WP остаются в сцене для визуального редактирования, а SO хранит данные. Для автоматического подхвата добавим custom editor с кнопкой "Update from Scene".

1. **Измените LevelPath.cs на Vector3[]**  
   Откройте скрипт и замените на это:
```csharp
   using UnityEngine;

   [CreateAssetMenu(fileName = "LevelPath", menuName = "TD/LevelPath")]
   public class LevelPath : ScriptableObject
   {
       public Vector3[] points;
   }
```
   Зачем?  
   >Vector3 — примитив (числа X, Y, Z), ==SO может хранить их без проблем==. Нет ссылок на объекты, так что нет ограничений.

2. **Измените EnemyMovement.cs (если есть)**  
   >В скрипте движения врагов замените Transform[] на Vector3[]:
   ```csharp
   - private Vector3[] points => path.points;  
   - Vector3 targetPos = points[currentPointIndex + 1];  
   ```
   ==Это работает так же, но использует позиции, а не Transform.==


3. **Добавьте custom editor для автоматического подхвата**  
   Создайте папку Editor в Assets (если нет).  
   В Editor создайте C# Script — ==LevelPathEditor.cs== (копируй имя файла и вставляй при создании скрипта)
   Вставьте этот код:

```csharp
   #if UNITY_EDITOR  
   using UnityEngine;  
   using UnityEditor;  

   [CustomEditor(typeof(LevelPath))]  
   public class LevelPathEditor : Editor  
   {  
       public override void OnInspectorGUI()  
       {  
           DrawDefaultInspector();  

           LevelPath path = (LevelPath)target;  
           if (GUILayout.Button("Update Path from Scene"))  
           {  
               GameObject waypointsGO = GameObject.Find("Waypoints");  
               if (waypointsGO == null)  
               {  
                   EditorUtility.DisplayDialog("Ошибка", "Не найден Waypoints!", "OK");  
                   return;  
               }  

               Transform[] transforms = waypointsGO.GetComponentsInChildren<Transform>();  
               path.points = new Vector3[transforms.Length];  
               for (int i = 0; i < transforms.Length; i++)  
               {  
                   path.points[i] = transforms[i].position;  
               }  

               EditorUtility.SetDirty(path);  
               EditorUtility.DisplayDialog("Готово", $"Обновлено {path.points.Length} точек", "OK");  
               }  
       }  
   }  
   #endif
```
   > Зачем?  
   В Inspector LevelPath.asset появится кнопка "Update Path from Scene".  
   Нажми — она автоматически соберёт позиции всех дочерних WP из Waypoints.  
   Это стандарт в студиях: дизайнеры редактируют точки в сцене, а кнопка обновляет SO.

1. **Как использовать на разных уровнях**  
   - Для ==Level1== — создай Level1.scene, поставь свои Waypoints, обнови ==Level1_Path.asset== кнопкой.  
   - Для ==Level2== — новая сцена, новые точки, ==новый asset== (Assets → Create → TD → LevelPath).  
   - В скрипте врага: [SerializeField] private LevelPath path; — перетащи нужный asset в инспекторе.  
   - Для автоматического подхвата: в GameManager на старте сцены найди Waypoints и обнови SO, если нужно.


---


#### Профессиональный совет:

В реальных проектах делают кнопку =="Collect from Children"== в custom editor
(чтобы не перетаскивать 50 точек вручную)

Результат дня 3

В Hierarchy есть объект Waypoints с 16 дочерними точками WP0–WP15
Все точки стоят точно по центру дороги
Есть файл LevelPath.asset, в котором массив из 16 ссылок на эти точки
Теперь путь можно легко редактировать мышкой → изменения сразу видны в инспекторе LevelPath

Проверка:

Перетащите любую точку WP в сторону → посмотрите в LevelPath.asset — координаты обновились
Нажмите Play → ничего не должно происходить (врагов пока нет)
Всё работает → день пройден!

Готовы к Дню 4 (движение врага по пути)?
