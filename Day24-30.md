**Предполагаемое состояние после Месяца 2:**
- 4 башни с улучшениями
- магазин с ghost-превью и проверкой на слой Buildable
- полноценная экономика (золото, трата, продажа)
- жизни, экраны победы/поражения
- базовый HUD
- одна волна с одним типом врага (слизень)

### День 25 — Префабы остальных врагов (Spider, Troll, Wraith)

**Цель дня:** Создать префабы для всех типов врагов кроме босса.

1. В папке **Prefabs/Enemies** → дублируйте **EnemySlime.prefab** → переименуйте в **EnemySpider.prefab**

2. Откройте префаб и измените:

   - SpriteRenderer → спрайт паука (Kenney)
   - Scale → 0.9 × 0.9 × 1
   - CircleCollider2D → Radius ≈ 0.45
   - EnemyHealth → maxHealth = 180, goldReward = 12
   - EnemyMovement → speed = 3.2f (быстрее слизня)

3. Аналогично создайте:

   **EnemyTroll.prefab**
   - Sprite → тролль/каменный голем
   - Scale → 1.4 × 1.4 × 1
   - Collider Radius ≈ 0.7
   - Health → maxHealth = 550, goldReward = 30
   - Movement → speed = 1.4f (медленный)

   **EnemyWraith.prefab**
   - Sprite → призрак/дух
   - Scale → 1.0 × 1.0 × 1
   - Collider Radius ≈ 0.5
   - Health → maxHealth = 280, goldReward = 18
   - Movement → speed = 2.8f

**Контрольная проверка дня 25**  
Перетащите все 4 префаба в сцену → Play → каждый враг должен идти по пути с разной скоростью и иметь разное здоровье.

---

### День 26 — Летающий враг (Wraith) + иммунитет к наземным башням

**Цель дня:** Реализовать механику летающих врагов.

1. Создайте новый скрипт **FlyingEnemy.cs** и прикрепите только к **EnemyWraith.prefab**

```csharp
using UnityEngine;

public class FlyingEnemy : MonoBehaviour
{
    public bool isFlying = true;
}
```

2. В **TowerController.cs** измените метод UpdateTarget():

```csharp
void UpdateTarget()
{
    Collider2D[] hits = Physics2D.OverlapCircleAll(transform.position, currentRange);

    Transform nearest = null;
    float minDist = float.MaxValue;

    foreach (var hit in hits)
    {
        if (hit.CompareTag("Enemy"))
        {
            // Проверяем, летает ли враг
            FlyingEnemy flying = hit.GetComponent<FlyingEnemy>();
            if (flying != null && flying.isFlying)
            {
                // Пропускаем летающих, если башня не умеет их атаковать
                if (!data.canHitFlying) continue;
            }

            float dist = Vector2.Distance(transform.position, hit.transform.position);
            if (dist < minDist)
            {
                minDist = dist;
                nearest = hit.transform;
            }
        }
    }

    target = nearest;
}
```

3. В каждом **TowerData** добавьте поле:

```csharp
public bool canHitFlying = false;
```

4. Заполните значения:
   - ArcherTowerData → canHitFlying = false
   - FireTowerData → canHitFlying = true
   - FrostTowerData → canHitFlying = false
   - ChainTowerData → canHitFlying = true

**Контрольная проверка дня 26**  
Поставьте стрелковую и ледяную башню → призрак (Wraith) проходит мимо них без урона.  
Поставьте огненную и цепную → они должны стрелять по призраку.

---

### День 27 — Босс (Fire Golem) + визуальные эффекты появления

**Цель дня:** Создать босса с эпичным появлением.

1. Дублируйте любой враг → **EnemyBoss.prefab**

2. Изменения:
   - Sprite → большой огненный голем (Kenney или другой)
   - Scale → 2.2 × 2.2 × 1
   - Collider Radius → 1.2
   - EnemyHealth → maxHealth = 2200, goldReward = 120
   - EnemyMovement → speed = 1.1f
   - Добавьте Particle System (огонь вокруг) → Rate over Time = 20, Start Lifetime = 0.8

3. Добавьте скрипт **BossEnemy.cs** (на префаб):

```csharp
using UnityEngine;

public class BossEnemy : MonoBehaviour
{
    private void Start()
    {
        // Экранная тряска при появлении
        if (Camera.main.TryGetComponent<CinemachineImpulseSource>(out var impulse))
        {
            impulse.GenerateImpulse(Vector3.one * 0.8f);
        }
        
        // Громкий звук появления (позже)
    }
}
```

4. (Опционально) Добавьте **Cinemachine Impulse Source** на Main Camera для тряски.

**Контрольная проверка дня 27**  
Перетащите босса в сцену → он идёт медленно, много здоровья, вокруг огонь, при старте камера трясётся (если Cinemachine настроен).

---

### День 28 — Ледяная башня — замедление врагов

**Цель дня:** Реализовать механику замедления.

1. В **TowerData** добавьте поля для ледяной башни:

```csharp
[Header("Замедление (только для Frost)")]
public float slowAmount = 0.5f;         // 50% скорости
public float slowDuration = 3f;
```

2. В **Bullet.cs** добавьте:

```csharp
[HideInInspector] public TowerData sourceTowerData;  // откуда пуля

private void OnTriggerEnter2D(Collider2D other)
{
    if (other.CompareTag("Enemy"))
    {
        EnemyHealth health = other.GetComponent<EnemyHealth>();
        EnemyMovement movement = other.GetComponent<EnemyMovement>();

        if (health != null)
        {
            health.TakeDamage(damage);
        }

        // Замедление
        if (sourceTowerData != null && sourceTowerData.slowAmount < 1f && movement != null)
        {
            movement.ApplySlow(sourceTowerData.slowAmount, sourceTowerData.slowDuration);
        }

        Destroy(gameObject);
    }
}
```

3. В **TowerController.Shoot()** добавьте:

```csharp
bullet.sourceTowerData = data;
```

4. В **EnemyMovement.cs** добавьте:

```csharp
private float speedMultiplier = 1f;
private float slowTimer = 0f;

public void ApplySlow(float amount, float duration)
{
    speedMultiplier = Mathf.Min(speedMultiplier, amount);
    slowTimer = Mathf.Max(slowTimer, duration);
}

private void Update()
{
    // ... существующий код движения ...

    float currentSpeed = speed * speedMultiplier;

    // ... используйте currentSpeed вместо speed

    // Обновление таймера замедления
    if (slowTimer > 0)
    {
        slowTimer -= Time.deltaTime;
        if (slowTimer <= 0)
        {
            speedMultiplier = 1f;
        }
    }
}
```

**Контрольная проверка дня 28**  
Постройте ледяную башню → враги, попавшие под выстрел, заметно замедляются на 2–3 секунды.

---

### День 29 — Цепная молния (Chain Lightning)

**Цель дня:** Реализовать атаку по нескольким целям.

1. Создайте новый префаб **ChainBullet.prefab** (дубликат обычного Bullet)

2. Создайте скрипт **ChainLightningBullet.cs**

```csharp
using UnityEngine;

public class ChainLightningBullet : MonoBehaviour
{
    public float speed = 12f;
    public float damage = 35f;
    public int maxChains = 4;
    public float chainRange = 3f;
    public float damageFalloff = 0.75f;

    private Transform currentTarget;
    private int chainsUsed = 0;

    public void Initialize(Transform startTarget)
    {
        currentTarget = startTarget;
        chainsUsed = 0;
    }

    private void Update()
    {
        if (currentTarget == null)
        {
            Destroy(gameObject);
            return;
        }

        Vector2 dir = (currentTarget.position - transform.position).normalized;
        transform.position += (Vector3)dir * speed * Time.deltaTime;

        if (Vector2.Distance(transform.position, currentTarget.position) < 0.3f)
        {
            HitTarget();
        }
    }

    void HitTarget()
    {
        if (currentTarget == null) return;

        EnemyHealth health = currentTarget.GetComponent<EnemyHealth>();
        if (health) health.TakeDamage(damage);

        chainsUsed++;
        if (chainsUsed >= maxChains)
        {
            Destroy(gameObject);
            return;
        }

        damage *= damageFalloff;

        // Ищем следующую цель
        Collider2D[] hits = Physics2D.OverlapCircleAll(currentTarget.position, chainRange);
        Transform next = null;
        float minDist = float.MaxValue;

        foreach (var hit in hits)
        {
            if (hit.CompareTag("Enemy") && hit.transform != currentTarget)
            {
                float dist = Vector2.Distance(currentTarget.position, hit.transform.position);
                if (dist < minDist)
                {
                    minDist = dist;
                    next = hit.transform;
                }
            }
        }

        if (next != null)
        {
            currentTarget = next;
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

3. В **TowerController** для цепной башни создайте отдельный Shoot():

```csharp
// В Shoot() добавить условие
if (data.isChainLightning)
{
    GameObject chainGO = Instantiate(bulletPrefab, firePoint.position, Quaternion.identity);
    ChainLightningBullet chain = chainGO.GetComponent<ChainLightningBullet>();
    if (chain != null)
    {
        chain.Initialize(target);
    }
}
else
{
    // обычная пуля
}
```

**Контрольная проверка дня 29**  
Постройте цепную башню → при попадании в группу врагов молния должна перепрыгивать на 3–4 ближайших.

---

### День 30 — Визуальные эффекты попаданий и смерти

**Цель дня:** Красивые частицы для попаданий и смерти.

1. Создайте 5 Particle System префабов в **Prefabs/Effects**:

   - Hit_Arrow (белые искры)
   - Hit_Fire (оранжевый взрыв)
   - Hit_Frost (синие кристаллы)
   - Hit_Chain (фиолетовые молнии)
   - DeathExplosion (общий взрыв при смерти)

2. В **EnemyHealth.TakeDamage()** добавьте:

```csharp
[SerializeField] private GameObject hitEffectPrefab;

if (hitEffectPrefab)
{
    Instantiate(hitEffectPrefab, transform.position, Quaternion.identity);
}
```

3. В **EnemyMovement** или **EnemyHealth.Die()** добавьте:

```csharp
[SerializeField] private GameObject deathEffectPrefab;

private void Die()
{
    if (deathEffectPrefab)
    {
        Instantiate(deathEffectPrefab, transform.position, Quaternion.identity);
    }
    BuildManager.main.AddGold(goldReward);
    Destroy(gameObject);
}
```

**Контрольная проверка дня 30**  
При попадании и смерти врагов появляются соответствующие частицы.

---

**Итог Месяца 3 (дни 25–30)**  
К концу этих 6 дней у вас должно быть:
- 5 типов врагов (4 обычных + босс)
- Летающие враги с иммунитетом к некоторым башням
- Замедление от ледяной башни
- Цепная молния
- Красивые эффекты попаданий и смерти