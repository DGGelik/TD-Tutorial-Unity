**Предполагаемое состояние после Месяца 3:**
- все механики игры работают (башни, враги, эффекты, звук, баланс волн)
- игра стабильна на 12 волнах
- есть базовый HUD, экраны победы/поражения
- есть AudioManager с музыкой и звуками

### День 37 — Главное меню (MainMenu сцена)

**Цель дня:** Создать отдельную стартовую сцену с меню.

1. File → New Scene → Basic (2D) → сохраните как **MainMenu.unity**

2. В Build Settings → Add Open Scenes → добавьте обе сцены:
   - 0: MainMenu
   - 1: Main

3. В MainMenu создайте **UICanvas** (как в игре)

4. Добавьте элементы:

   - Image (фон) — растяните на весь экран, используйте красивый спрайт замка/кристалла
   - TextMeshPro — название игры (размер 120–140, золотой цвет)
   - Три кнопки (UI → Button):

     | Кнопка     | Текст          | OnClick действие                              |
     |------------|----------------|-----------------------------------------------|
     | Play       | Играть         | SceneManager.LoadScene("Main")                |
     | Options    | Настройки      | Пока пусто (откроем позже)                    |
     | Quit       | Выход          | Application.Quit()                            |

5. Создайте скрипт **MainMenu.cs** и прикрепите к Canvas:

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;

public class MainMenu : MonoBehaviour
{
    public void PlayGame()
    {
        SceneManager.LoadScene("Main");
    }

    public void QuitGame()
    {
        #if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
        #else
            Application.Quit();
        #endif
    }
}
```

6. На кнопках Play и Quit назначьте соответствующие методы.

**Контрольная проверка дня 37**  
Build & Run → проект открывается с красивым меню → кнопка «Играть» запускает основной уровень, «Выход» закрывает игру.

---

### День 38 — Пауза и игровое меню (в сцене Main)

**Цель дня:** Добавить возможность поставить игру на паузу.

1. В **UICanvas** (в сцене Main) создайте Panel → назовите **PausePanel** → отключите (SetActive(false))

2. Внутри PausePanel:

   - Полупрозрачный фон (Image, цвет #00000080)
   - TextMeshPro «ПАУЗА» (размер 100)
   - Три кнопки:
     - Продолжить → Resume
     - Начать заново → Restart
     - В главное меню → MainMenu

3. Создайте скрипт **PauseManager.cs** и прикрепите к UICanvas:

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;

public class PauseManager : MonoBehaviour
{
    [SerializeField] private GameObject pausePanel;
    private bool isPaused = false;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (isPaused)
                Resume();
            else
                Pause();
        }
    }

    public void Pause()
    {
        pausePanel.SetActive(true);
        Time.timeScale = 0f;
        isPaused = true;
    }

    public void Resume()
    {
        pausePanel.SetActive(false);
        Time.timeScale = 1f;
        isPaused = false;
    }

    public void Restart()
    {
        Time.timeScale = 1f;
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }

    public void LoadMainMenu()
    {
        Time.timeScale = 1f;
        SceneManager.LoadScene("MainMenu");
    }
}
```

4. На кнопках PausePanel назначьте методы Resume / Restart / LoadMainMenu.

**Контрольная проверка дня 38**  
Во время игры нажмите Esc → появляется пауза, время останавливается.  
Кнопки работают корректно.

---

### День 39 — Базовые настройки (громкость музыки и эффектов)

**Цель дня:** Добавить простые настройки громкости.

1. В MainMenu создайте Panel → **OptionsPanel** (неактивен)

2. Внутри добавьте:

   - Text «Настройки»
   - Slider «Музыка» (0–1)
   - Slider «Звуки» (0–1)
   - Button «Назад»

3. Создайте AudioMixer (Assets → Create → Audio Mixer → MyMixer)

4. В AudioManager добавьте:

```csharp
using UnityEngine.Audio;

public AudioMixer mixer;

private void Start()
{
    // ... существующий код ...

    float savedMusic = PlayerPrefs.GetFloat("MusicVolume", 0.35f);
    float savedSFX = PlayerPrefs.GetFloat("SFXVolume", 0.7f);

    mixer.SetFloat("MusicVolume", Mathf.Log10(savedMusic) * 20);
    mixer.SetFloat("SFXVolume", Mathf.Log10(savedSFX) * 20);
}
```

5. Создайте скрипт **SettingsMenu.cs** на OptionsPanel:

```csharp
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Audio;

public class SettingsMenu : MonoBehaviour
{
    [SerializeField] private Slider musicSlider;
    [SerializeField] private Slider sfxSlider;
    [SerializeField] private AudioMixer mixer;

    private void Start()
    {
        musicSlider.value = PlayerPrefs.GetFloat("MusicVolume", 0.35f);
        sfxSlider.value = PlayerPrefs.GetFloat("SFXVolume", 0.7f);

        musicSlider.onValueChanged.AddListener(SetMusicVolume);
        sfxSlider.onValueChanged.AddListener(SetSFXVolume);
    }

    public void SetMusicVolume(float value)
    {
        mixer.SetFloat("MusicVolume", Mathf.Log10(value) * 20);
        PlayerPrefs.SetFloat("MusicVolume", value);
    }

    public void SetSFXVolume(float value)
    {
        mixer.SetFloat("SFXVolume", Mathf.Log10(value) * 20);
        PlayerPrefs.SetFloat("SFXVolume", value);
    }
}
```

6. Назначьте слайдеры и AudioMixer в инспекторе.

**Контрольная проверка дня 39**  
В меню → Настройки → ползунки меняют громкость музыки и звуков → значения сохраняются после перезапуска.

---

### День 40 — Экран загрузки + плавные переходы между сценами

**Цель дня:** Красивый переход между MainMenu и игрой.

1. Создайте новую сцену **Loading.unity**

2. В ней — Canvas с:
   - Image (фон)
   - TextMeshPro «Загрузка...» + анимированный прогресс-бар (или просто вращающийся круг)

3. Создайте скрипт **LoadingScreen.cs**:

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using System.Collections;

public class LoadingScreen : MonoBehaviour
{
    [SerializeField] private Slider progressBar; // опционально

    private void Start()
    {
        StartCoroutine(LoadGame());
    }

    IEnumerator LoadGame()
    {
        AsyncOperation operation = SceneManager.LoadSceneAsync("Main");
        operation.allowSceneActivation = false;

        while (!operation.isDone)
        {
            float progress = Mathf.Clamp01(operation.progress / 0.9f);
            if (progressBar) progressBar.value = progress;

            if (operation.progress >= 0.9f)
            {
                operation.allowSceneActivation = true;
            }

            yield return null;
        }
    }
}
```

4. В MainMenu на кнопке Play → вместо прямого LoadScene:

```csharp
SceneManager.LoadScene("Loading");
```

**Контрольная проверка дня 40**  
Нажатие «Играть» → появляется экран загрузки → плавный переход в игру.

---

### День 41 — Финальная визуальная полировка UI и эффекты

**Цель дня:** Добавить анимации и улучшить внешний вид.

1. Анимация получения золота:

   - В UIManager добавьте анимацию для GoldText (увеличение и возврат размера при +gold)

2. Damage numbers (цифры урона над врагами):

   - Создайте префаб DamageText (Canvas World Space + TextMeshPro)
   - В EnemyHealth.TakeDamage():

```csharp
GameObject dmgText = Instantiate(damageTextPrefab, transform.position + Vector3.up * 0.8f, Quaternion.identity);
dmgText.GetComponentInChildren<TextMeshProUGUI>().text = amount.ToString();
Destroy(dmgText, 1.2f);
```

3. Конфетти на победе:

   - Particle System на VictoryPanel (цветные частицы, Rate over Time = 0, Burst на старте)

4. Fade-in/out для экранов:

   - Добавьте Image (чёрный фон) на Victory/GameOver → анимируйте alpha от 0 до 1

**Контрольная проверка дня 41**  
Игра выглядит гораздо красивее: цифры урона, анимированное золото, конфетти при победе.

---

### День 42 — Пост-эффекты (URP Bloom, Vignette, цветокоррекция)

**Цель дня:** Добавить визуальные эффекты через Universal Render Pipeline.

1. Если проект ещё не на URP:
   - Window → Package Manager → Universal RP → Install
   - Edit → Project Settings → Graphics → Scriptable Render Pipeline Settings → создайте URP Asset

2. На Main Camera добавьте **Volume** → Global Volume → New Profile

3. Добавьте Overrides:
   - Bloom (Intensity 0.8–1.2, Threshold 0.9)
   - Vignette (Intensity 0.35, особенно на поздних волнах)
   - Color Adjustments (Post Exposure +0.15, Contrast +10 на победу)

4. Создайте скрипт **DynamicPostProcessing.cs** для изменения эффектов:

```csharp
public void IntensifyEffects(bool intense)
{
    // Пример: увеличить Vignette и Bloom на поздних волнах
}
```

**Контрольная проверка дня 42**  
Выстрелы и эффекты светятся (Bloom), края экрана затемнены (Vignette), картинка выглядит более кинематографично.

---

### День 43–45 — Массовое тестирование, фикс багов, финальная оптимизация

**Цель дней:** Довести игру до релизного состояния.

**День 43**  
- Каждый участник проходит уровень минимум 5 раз  
- Записывают все баги в общий документ  
- Типичные баги: target null после смерти, звуки не останавливаются, UI не обновляется при продаже, волны не заканчиваются

**День 44**  
- Фикс 10–15 самых важных багов  
- Добавление Object Pooling для эффектов частиц (аналогично пулям)  
- Проверка на слабых ПК (Profiler → FPS > 55 при 40 врагах)

**День 45**  
- Финальный билд  
- Тест на разных разрешениях экрана  
- Проверка всех кнопок (меню, пауза, настройки, рестарт)

**Контрольная проверка дней 43–45**  
Игра проходит 12 волн без крашей, выглядит красиво, звучит хорошо, управляется удобно.

---

### День 46–48 — Релиз, GitHub, itch.io, видео

**Цель дней:** Подготовить проект к показу.

**День 46**  
- Создать репозиторий GitHub: CrystalBastion  
- Добавить .gitignore для Unity  
- Закоммитить весь проект  
- Создать README.md с описанием, скриншотами, управлением

**День 47**  
- Сборка финального билда  
- Загрузка на itch.io (zip с билдом + скриншоты + описание)  
- Опционально: WebGL билд (если позволяет время)

**День 48**  
- Запись видео прохождения (OBS Studio или встроенная запись Windows)  
  - 3–5 минут: меню → начало игры → стратегия → победа  
- Подготовка короткой презентации (5–7 слайдов): идея, что сделано, сложности, результат

**Контрольная проверка дней 46–48**  
- Репозиторий на GitHub публичный  
- Страница на itch.io готова  
- Видео загружено (YouTube или в репозиторий)

---

**Итог Месяца 4 и всего проекта**  
К концу февраля–мая 2026 у вас должна быть полноценная законченная игра Tower Defense, готовая к показу, публикации и портфолио.

Если хочешь, можем теперь:
- составить шаблон README.md для GitHub  
- список самых частых багов и их решений  
- план презентации проекта  
- или вернуться и доработать любой конкретный день любого месяца